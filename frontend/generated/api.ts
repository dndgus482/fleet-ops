/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Response object representing agent connection information
 * @export
 * @interface AgentConnectionRes
 */
export interface AgentConnectionRes {
    /**
     * IP address of the agent
     * @type {string}
     * @memberof AgentConnectionRes
     */
    'ip': string;
    /**
     * Username of the agent
     * @type {string}
     * @memberof AgentConnectionRes
     */
    'userName': string;
    /**
     * Connection status
     * @type {boolean}
     * @memberof AgentConnectionRes
     */
    'connected': boolean;
    /**
     * Connection log details
     * @type {string}
     * @memberof AgentConnectionRes
     */
    'log': string;
}
/**
 * Agent group response object
 * @export
 * @interface AgentGroupRes
 */
export interface AgentGroupRes {
    /**
     * ID of the agent group
     * @type {string}
     * @memberof AgentGroupRes
     */
    'agentGroupId': string;
    /**
     * Name of the agent group
     * @type {string}
     * @memberof AgentGroupRes
     */
    'agentGroupName': string;
    /**
     * Description of the agent group
     * @type {string}
     * @memberof AgentGroupRes
     */
    'agentGroupDescription': string;
    /**
     * List of agents in the group
     * @type {Array<AgentRes>}
     * @memberof AgentGroupRes
     */
    'agents': Array<AgentRes>;
    /**
     * List of tags associated with the group
     * @type {Array<string>}
     * @memberof AgentGroupRes
     */
    'tags': Array<string>;
    /**
     * Whether the group is active
     * @type {boolean}
     * @memberof AgentGroupRes
     */
    'active': boolean;
}
/**
 * Request object containing agent connection information 
 * @export
 * @interface AgentReq
 */
export interface AgentReq {
    /**
     * IP address of the agent in IPv4 format 
     * @type {string}
     * @memberof AgentReq
     */
    'ip'?: string;
    /**
     * Username for SSH login (1–100 characters allowed) ⚠️ Maximum 100 characters 
     * @type {string}
     * @memberof AgentReq
     */
    'userName'?: string;
}
/**
 * 
 * @export
 * @interface AgentRes
 */
export interface AgentRes {
    /**
     * IP address of the agent
     * @type {string}
     * @memberof AgentRes
     */
    'ip': string;
    /**
     * Username for SSH access
     * @type {string}
     * @memberof AgentRes
     */
    'userName': string;
}
/**
 * 
 * @export
 * @interface GetJobById400Response
 */
export interface GetJobById400Response {
    /**
     * 
     * @type {string}
     * @memberof GetJobById400Response
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJobById400Response
     */
    'timestamp'?: string;
}
/**
 * Response containing details of the executed job
 * @export
 * @interface JobExecuteRes
 */
export interface JobExecuteRes {
    /**
     * Identifier of the job
     * @type {string}
     * @memberof JobExecuteRes
     */
    'jobId': string;
    /**
     * Execution number of the job
     * @type {number}
     * @memberof JobExecuteRes
     */
    'jobExecutionNo': number;
}
/**
 * Response containing detailed information about a specific job execution.
 * @export
 * @interface JobExecutionRes
 */
export interface JobExecutionRes {
    /**
     * Identifier of the job
     * @type {string}
     * @memberof JobExecutionRes
     */
    'jobId': string;
    /**
     * Name of the job
     * @type {string}
     * @memberof JobExecutionRes
     */
    'jobName': string;
    /**
     * Execution number of the job execution
     * @type {number}
     * @memberof JobExecutionRes
     */
    'jobExecutionNo': number;
    /**
     * Job history number linked to the execution
     * @type {number}
     * @memberof JobExecutionRes
     */
    'jobHistoryNo': number;
    /**
     * Current status of the job execution
     * @type {string}
     * @memberof JobExecutionRes
     */
    'jobExecutionStatus': JobExecutionResJobExecutionStatusEnum;
    /**
     * User ID of the user who executed the job
     * @type {string}
     * @memberof JobExecutionRes
     */
    'executionUserId': string;
    /**
     * Date and time when the job was executed
     * @type {string}
     * @memberof JobExecutionRes
     */
    'executionDateTime': string;
    /**
     * Date and time when the execution started
     * @type {string}
     * @memberof JobExecutionRes
     */
    'startDateTime'?: string;
    /**
     * Date and time when the execution ended
     * @type {string}
     * @memberof JobExecutionRes
     */
    'endDateTime'?: string;
    /**
     * List of target agents involved in this job execution
     * @type {Array<JobExecutionTargetAgentRes>}
     * @memberof JobExecutionRes
     */
    'targetAgents': Array<JobExecutionTargetAgentRes>;
}

export const JobExecutionResJobExecutionStatusEnum = {
    Created: 'CREATED',
    Ready: 'READY',
    Started: 'STARTED',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Stopped: 'STOPPED',
    Skipped: 'SKIPPED'
} as const;

export type JobExecutionResJobExecutionStatusEnum = typeof JobExecutionResJobExecutionStatusEnum[keyof typeof JobExecutionResJobExecutionStatusEnum];

/**
 * Request to search job executions based on various criteria
 * @export
 * @interface JobExecutionSearchReq
 */
export interface JobExecutionSearchReq {
    /**
     * sort field
     * @type {string}
     * @memberof JobExecutionSearchReq
     */
    'sortField'?: string;
    /**
     * sort direction
     * @type {string}
     * @memberof JobExecutionSearchReq
     */
    'sortDirection'?: JobExecutionSearchReqSortDirectionEnum;
    /**
     * null if first search
     * @type {string}
     * @memberof JobExecutionSearchReq
     */
    'pageToken'?: string;
    /**
     * max size to get
     * @type {number}
     * @memberof JobExecutionSearchReq
     */
    'maxPageSize'?: number;
    /**
     * Identifier of the job to filter by
     * @type {string}
     * @memberof JobExecutionSearchReq
     */
    'jobId'?: string;
    /**
     * Agent group ID to filter by
     * @type {string}
     * @memberof JobExecutionSearchReq
     */
    'agentGroupId'?: string;
    /**
     * IP address of the agent, nullable if not applicable
     * @type {string}
     * @memberof JobExecutionSearchReq
     */
    'ip'?: string;
}

export const JobExecutionSearchReqSortDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type JobExecutionSearchReqSortDirectionEnum = typeof JobExecutionSearchReqSortDirectionEnum[keyof typeof JobExecutionSearchReqSortDirectionEnum];

/**
 * Response containing details about a target agent involved in job execution
 * @export
 * @interface JobExecutionTargetAgentRes
 */
export interface JobExecutionTargetAgentRes {
    /**
     * IP address of the agent
     * @type {string}
     * @memberof JobExecutionTargetAgentRes
     */
    'ip': string;
    /**
     * Username of the agent
     * @type {string}
     * @memberof JobExecutionTargetAgentRes
     */
    'userName': string;
    /**
     * Date and time when the agent started the execution
     * @type {string}
     * @memberof JobExecutionTargetAgentRes
     */
    'startDateTime': string;
    /**
     * Date and time when the agent finished the execution
     * @type {string}
     * @memberof JobExecutionTargetAgentRes
     */
    'endDateTime': string;
    /**
     * Log details specific to this agent\'s execution
     * @type {string}
     * @memberof JobExecutionTargetAgentRes
     */
    'log': string;
}
/**
 * Response containing details of a job\'s execution history
 * @export
 * @interface JobHistoryRes
 */
export interface JobHistoryRes {
    /**
     * Unique identifier of the job
     * @type {string}
     * @memberof JobHistoryRes
     */
    'jobId': string;
    /**
     * Unique number for the job history
     * @type {number}
     * @memberof JobHistoryRes
     */
    'jobHistoryNo': number;
    /**
     * Name of the job
     * @type {string}
     * @memberof JobHistoryRes
     */
    'jobName': string;
    /**
     * Type of the job
     * @type {string}
     * @memberof JobHistoryRes
     */
    'jobType': JobHistoryResJobTypeEnum;
    /**
     * Additional history details of the job represented as key-value pairs
     * @type {{ [key: string]: object; }}
     * @memberof JobHistoryRes
     */
    'history': { [key: string]: object; };
    /**
     * User ID of the person who registered the job
     * @type {string}
     * @memberof JobHistoryRes
     */
    'regUserId': string;
    /**
     * Date and time when the job was registered
     * @type {string}
     * @memberof JobHistoryRes
     */
    'regDateTime': string;
}

export const JobHistoryResJobTypeEnum = {
    Ssh: 'SSH'
} as const;

export type JobHistoryResJobTypeEnum = typeof JobHistoryResJobTypeEnum[keyof typeof JobHistoryResJobTypeEnum];

/**
 * Request to search job history based on various criteria
 * @export
 * @interface JobHistorySearchReq
 */
export interface JobHistorySearchReq {
    /**
     * sort field
     * @type {string}
     * @memberof JobHistorySearchReq
     */
    'sortField'?: string;
    /**
     * sort direction
     * @type {string}
     * @memberof JobHistorySearchReq
     */
    'sortDirection'?: JobHistorySearchReqSortDirectionEnum;
    /**
     * null if first search
     * @type {string}
     * @memberof JobHistorySearchReq
     */
    'pageToken'?: string;
    /**
     * max size to get
     * @type {number}
     * @memberof JobHistorySearchReq
     */
    'maxPageSize'?: number;
}

export const JobHistorySearchReqSortDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type JobHistorySearchReqSortDirectionEnum = typeof JobHistorySearchReqSortDirectionEnum[keyof typeof JobHistorySearchReqSortDirectionEnum];

/**
 * Response containing details of a job
 * @export
 * @interface JobRes
 */
export interface JobRes {
    /**
     * Unique identifier of the job
     * @type {string}
     * @memberof JobRes
     */
    'jobId': string;
    /**
     * Name of the job
     * @type {string}
     * @memberof JobRes
     */
    'jobName': string;
    /**
     * Description of the job
     * @type {string}
     * @memberof JobRes
     */
    'jobDescription': string;
    /**
     * Type of the job
     * @type {string}
     * @memberof JobRes
     */
    'jobType': JobResJobTypeEnum;
    /**
     * Indicates whether the job is active or not
     * @type {boolean}
     * @memberof JobRes
     */
    'active': boolean;
    /**
     * List of target agents assigned to the job
     * @type {Array<TargetAgentRes>}
     * @memberof JobRes
     */
    'targetAgents'?: Array<TargetAgentRes>;
    /**
     * Execution period of the job in cron format
     * @type {string}
     * @memberof JobRes
     */
    'period'?: string;
    /**
     * Script associated with the job
     * @type {string}
     * @memberof JobRes
     */
    'script'?: string;
}

export const JobResJobTypeEnum = {
    Ssh: 'SSH'
} as const;

export type JobResJobTypeEnum = typeof JobResJobTypeEnum[keyof typeof JobResJobTypeEnum];

/**
 * 
 * @export
 * @interface JobSearchReq
 */
export interface JobSearchReq {
    /**
     * sort field
     * @type {string}
     * @memberof JobSearchReq
     */
    'sortField'?: string;
    /**
     * sort direction
     * @type {string}
     * @memberof JobSearchReq
     */
    'sortDirection'?: JobSearchReqSortDirectionEnum;
    /**
     * null if first search
     * @type {string}
     * @memberof JobSearchReq
     */
    'pageToken'?: string;
    /**
     * max size to get
     * @type {number}
     * @memberof JobSearchReq
     */
    'maxPageSize'?: number;
    /**
     * job name to filter by
     * @type {string}
     * @memberof JobSearchReq
     */
    'jobName'?: string;
}

export const JobSearchReqSortDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type JobSearchReqSortDirectionEnum = typeof JobSearchReqSortDirectionEnum[keyof typeof JobSearchReqSortDirectionEnum];

/**
 * 
 * @export
 * @interface PagedResultJobExecutionRes
 */
export interface PagedResultJobExecutionRes {
    /**
     * results of search
     * @type {Array<JobExecutionRes>}
     * @memberof PagedResultJobExecutionRes
     */
    'results': Array<JobExecutionRes>;
    /**
     * use this token for the next page
     * @type {string}
     * @memberof PagedResultJobExecutionRes
     */
    'nextPageToken'?: string;
    /**
     * total count of matched search results
     * @type {number}
     * @memberof PagedResultJobExecutionRes
     */
    'totalCount': number;
}
/**
 * 
 * @export
 * @interface PagedResultJobHistoryRes
 */
export interface PagedResultJobHistoryRes {
    /**
     * results of search
     * @type {Array<JobHistoryRes>}
     * @memberof PagedResultJobHistoryRes
     */
    'results': Array<JobHistoryRes>;
    /**
     * use this token for the next page
     * @type {string}
     * @memberof PagedResultJobHistoryRes
     */
    'nextPageToken'?: string;
    /**
     * total count of matched search results
     * @type {number}
     * @memberof PagedResultJobHistoryRes
     */
    'totalCount': number;
}
/**
 * 
 * @export
 * @interface PagedResultJobRes
 */
export interface PagedResultJobRes {
    /**
     * results of search
     * @type {Array<JobRes>}
     * @memberof PagedResultJobRes
     */
    'results': Array<JobRes>;
    /**
     * use this token for the next page
     * @type {string}
     * @memberof PagedResultJobRes
     */
    'nextPageToken'?: string;
    /**
     * total count of matched search results
     * @type {number}
     * @memberof PagedResultJobRes
     */
    'totalCount': number;
}
/**
 * Request DTO for saving an agent group including agents and tags.
 * @export
 * @interface SaveAgentGroupReq
 */
export interface SaveAgentGroupReq {
    /**
     * Name of the agent group ⚠️ Maximum 100 characters 
     * @type {string}
     * @memberof SaveAgentGroupReq
     */
    'agentGroupName'?: string;
    /**
     * Optional description for the agent group ⚠️ Maximum 1000 characters 
     * @type {string}
     * @memberof SaveAgentGroupReq
     */
    'agentGroupDescription'?: string;
    /**
     * List of agents belonging to this group ⚠️ Must not be empty 
     * @type {Array<AgentReq>}
     * @memberof SaveAgentGroupReq
     */
    'agents'?: Array<AgentReq>;
    /**
     * Optional list of tags associated with the group ⚠️ Can be empty or null 
     * @type {Array<string>}
     * @memberof SaveAgentGroupReq
     */
    'tags'?: Array<string>;
    /**
     * Whether the group is active ⚠️ Defaults to true if null 
     * @type {boolean}
     * @memberof SaveAgentGroupReq
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface SaveJobReq
 */
export interface SaveJobReq {
    /**
     * Name of the job
     * @type {string}
     * @memberof SaveJobReq
     */
    'jobName'?: string;
    /**
     * Description of the job
     * @type {string}
     * @memberof SaveJobReq
     */
    'jobDescription'?: string;
    /**
     * Type of the job
     * @type {string}
     * @memberof SaveJobReq
     */
    'jobType': SaveJobReqJobTypeEnum;
    /**
     * Indicates whether the job is active or not
     * @type {boolean}
     * @memberof SaveJobReq
     */
    'active'?: boolean;
    /**
     * 
     * @type {Array<TargetAgentReq>}
     * @memberof SaveJobReq
     */
    'targetAgents'?: Array<TargetAgentReq>;
    /**
     * 
     * @type {string}
     * @memberof SaveJobReq
     */
    'period'?: string;
    /**
     * 
     * @type {string}
     * @memberof SaveJobReq
     */
    'script'?: string;
}

export const SaveJobReqJobTypeEnum = {
    Ssh: 'SSH'
} as const;

export type SaveJobReqJobTypeEnum = typeof SaveJobReqJobTypeEnum[keyof typeof SaveJobReqJobTypeEnum];

/**
 * Response containing a simplified view of job details with only ID and name
 * @export
 * @interface SimpleJobNameRes
 */
export interface SimpleJobNameRes {
    /**
     * Unique identifier of the job
     * @type {string}
     * @memberof SimpleJobNameRes
     */
    'jobId': string;
    /**
     * Name of the job
     * @type {string}
     * @memberof SimpleJobNameRes
     */
    'jobName': string;
}
/**
 * Real-time log information for SSH job execution
 * @export
 * @interface SshLiveLog
 */
export interface SshLiveLog {
    /**
     * Index of the target agent
     * @type {number}
     * @memberof SshLiveLog
     */
    'agentIdx': number;
    /**
     * Index of the log line
     * @type {number}
     * @memberof SshLiveLog
     */
    'lineIdx': number;
    /**
     * Log content from SSH execution
     * @type {string}
     * @memberof SshLiveLog
     */
    'log': string;
}
/**
 * Request to switch the active state of a job
 * @export
 * @interface SwitchActiveReq
 */
export interface SwitchActiveReq {
    /**
     * Indicates whether the job should be active or inactive
     * @type {boolean}
     * @memberof SwitchActiveReq
     */
    'active': boolean;
}
/**
 * 
 * @export
 * @interface TargetAgentReq
 */
export interface TargetAgentReq {
    /**
     * 
     * @type {string}
     * @memberof TargetAgentReq
     */
    'targetAgentType': TargetAgentReqTargetAgentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TargetAgentReq
     */
    'agentGroupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TargetAgentReq
     */
    'ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof TargetAgentReq
     */
    'userName'?: string;
}

export const TargetAgentReqTargetAgentTypeEnum = {
    Group: 'GROUP',
    Agent: 'AGENT'
} as const;

export type TargetAgentReqTargetAgentTypeEnum = typeof TargetAgentReqTargetAgentTypeEnum[keyof typeof TargetAgentReqTargetAgentTypeEnum];

/**
 * Response containing details of a target agent
 * @export
 * @interface TargetAgentRes
 */
export interface TargetAgentRes {
    /**
     * Type of the target agent
     * @type {string}
     * @memberof TargetAgentRes
     */
    'targetAgentType': TargetAgentResTargetAgentTypeEnum;
    /**
     * Group ID of the target agents, if applicable
     * @type {string}
     * @memberof TargetAgentRes
     */
    'agentGroupId'?: string;
    /**
     * Group name of the target agents, if applicable
     * @type {string}
     * @memberof TargetAgentRes
     */
    'agentGroupName'?: string;
    /**
     * IP address of the target agent
     * @type {string}
     * @memberof TargetAgentRes
     */
    'ip'?: string;
    /**
     * Username associated with the target agent
     * @type {string}
     * @memberof TargetAgentRes
     */
    'userName'?: string;
}

export const TargetAgentResTargetAgentTypeEnum = {
    Group: 'GROUP',
    Agent: 'AGENT'
} as const;

export type TargetAgentResTargetAgentTypeEnum = typeof TargetAgentResTargetAgentTypeEnum[keyof typeof TargetAgentResTargetAgentTypeEnum];


/**
 * AgentGroupApi - axios parameter creator
 * @export
 */
export const AgentGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Test connection for given agents
         * @param {Array<AgentReq>} agentReqList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentConnectionTest: async (agentReqList: Array<AgentReq>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentReqList' is not null or undefined
            assertParamExists('agentConnectionTest', 'agentReqList', agentReqList)
            const localVarPath = `/api/agent/connectionTest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (agentReqList) {
                localVarQueryParameter['agentReqList'] = agentReqList;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test connection for all agents in a group
         * @param {string} agentGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentGroupConnectionTest: async (agentGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentGroupId' is not null or undefined
            assertParamExists('agentGroupConnectionTest', 'agentGroupId', agentGroupId)
            const localVarPath = `/api/agentGroups/{agentGroupId}/connectionTest`
                .replace(`{${"agentGroupId"}}`, encodeURIComponent(String(agentGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new agent group
         * @param {SaveAgentGroupReq} saveAgentGroupReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgentGroup: async (saveAgentGroupReq: SaveAgentGroupReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveAgentGroupReq' is not null or undefined
            assertParamExists('createAgentGroup', 'saveAgentGroupReq', saveAgentGroupReq)
            const localVarPath = `/api/agentGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveAgentGroupReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an agent group by ID
         * @param {string} agentGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgentGroupById: async (agentGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentGroupId' is not null or undefined
            assertParamExists('deleteAgentGroupById', 'agentGroupId', agentGroupId)
            const localVarPath = `/api/agentGroups/{agentGroupId}`
                .replace(`{${"agentGroupId"}}`, encodeURIComponent(String(agentGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get agent group by ID
         * @param {string} agentGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentGroupById: async (agentGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentGroupId' is not null or undefined
            assertParamExists('getAgentGroupById', 'agentGroupId', agentGroupId)
            const localVarPath = `/api/agentGroups/{agentGroupId}`
                .replace(`{${"agentGroupId"}}`, encodeURIComponent(String(agentGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get jobs linked to a specific agent group
         * @param {string} agentGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentGroupLinkedJobs: async (agentGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentGroupId' is not null or undefined
            assertParamExists('getAgentGroupLinkedJobs', 'agentGroupId', agentGroupId)
            const localVarPath = `/api/agentGroups/{agentGroupId}/linkedJobs`
                .replace(`{${"agentGroupId"}}`, encodeURIComponent(String(agentGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get jobs linked to a specific agent
         * @param {AgentReq} agentReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentLinkedJobs: async (agentReq: AgentReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentReq' is not null or undefined
            assertParamExists('getAgentLinkedJobs', 'agentReq', agentReq)
            const localVarPath = `/api/agent/linkedJobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (agentReq !== undefined) {
                for (const [key, value] of Object.entries(agentReq)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all agent groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAgentGroup: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/agentGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle active state of an agent group
         * @param {string} agentGroupId 
         * @param {SwitchActiveReq} switchActiveReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        switchActiveAgentGroup: async (agentGroupId: string, switchActiveReq: SwitchActiveReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentGroupId' is not null or undefined
            assertParamExists('switchActiveAgentGroup', 'agentGroupId', agentGroupId)
            // verify required parameter 'switchActiveReq' is not null or undefined
            assertParamExists('switchActiveAgentGroup', 'switchActiveReq', switchActiveReq)
            const localVarPath = `/api/agentGroups/{agentGroupId}/switchActive`
                .replace(`{${"agentGroupId"}}`, encodeURIComponent(String(agentGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(switchActiveReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing agent group
         * @param {string} agentGroupId 
         * @param {SaveAgentGroupReq} saveAgentGroupReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgentGroup: async (agentGroupId: string, saveAgentGroupReq: SaveAgentGroupReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentGroupId' is not null or undefined
            assertParamExists('updateAgentGroup', 'agentGroupId', agentGroupId)
            // verify required parameter 'saveAgentGroupReq' is not null or undefined
            assertParamExists('updateAgentGroup', 'saveAgentGroupReq', saveAgentGroupReq)
            const localVarPath = `/api/agentGroups/{agentGroupId}`
                .replace(`{${"agentGroupId"}}`, encodeURIComponent(String(agentGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveAgentGroupReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentGroupApi - functional programming interface
 * @export
 */
export const AgentGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AgentGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Test connection for given agents
         * @param {Array<AgentReq>} agentReqList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentConnectionTest(agentReqList: Array<AgentReq>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AgentConnectionRes>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentConnectionTest(agentReqList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGroupApi.agentConnectionTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Test connection for all agents in a group
         * @param {string} agentGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentGroupConnectionTest(agentGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AgentConnectionRes>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentGroupConnectionTest(agentGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGroupApi.agentGroupConnectionTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new agent group
         * @param {SaveAgentGroupReq} saveAgentGroupReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAgentGroup(saveAgentGroupReq: SaveAgentGroupReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentGroupRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAgentGroup(saveAgentGroupReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGroupApi.createAgentGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an agent group by ID
         * @param {string} agentGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAgentGroupById(agentGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAgentGroupById(agentGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGroupApi.deleteAgentGroupById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get agent group by ID
         * @param {string} agentGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgentGroupById(agentGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentGroupRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgentGroupById(agentGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGroupApi.getAgentGroupById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get jobs linked to a specific agent group
         * @param {string} agentGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgentGroupLinkedJobs(agentGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SimpleJobNameRes>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgentGroupLinkedJobs(agentGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGroupApi.getAgentGroupLinkedJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get jobs linked to a specific agent
         * @param {AgentReq} agentReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgentLinkedJobs(agentReq: AgentReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SimpleJobNameRes>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgentLinkedJobs(agentReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGroupApi.getAgentLinkedJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all agent groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAgentGroup(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AgentGroupRes>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAgentGroup(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGroupApi.getAllAgentGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Toggle active state of an agent group
         * @param {string} agentGroupId 
         * @param {SwitchActiveReq} switchActiveReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async switchActiveAgentGroup(agentGroupId: string, switchActiveReq: SwitchActiveReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentGroupRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.switchActiveAgentGroup(agentGroupId, switchActiveReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGroupApi.switchActiveAgentGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing agent group
         * @param {string} agentGroupId 
         * @param {SaveAgentGroupReq} saveAgentGroupReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAgentGroup(agentGroupId: string, saveAgentGroupReq: SaveAgentGroupReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentGroupRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAgentGroup(agentGroupId, saveAgentGroupReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGroupApi.updateAgentGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AgentGroupApi - factory interface
 * @export
 */
export const AgentGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AgentGroupApiFp(configuration)
    return {
        /**
         * 
         * @summary Test connection for given agents
         * @param {Array<AgentReq>} agentReqList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentConnectionTest(agentReqList: Array<AgentReq>, options?: RawAxiosRequestConfig): AxiosPromise<Array<AgentConnectionRes>> {
            return localVarFp.agentConnectionTest(agentReqList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test connection for all agents in a group
         * @param {string} agentGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentGroupConnectionTest(agentGroupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AgentConnectionRes>> {
            return localVarFp.agentGroupConnectionTest(agentGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new agent group
         * @param {SaveAgentGroupReq} saveAgentGroupReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgentGroup(saveAgentGroupReq: SaveAgentGroupReq, options?: RawAxiosRequestConfig): AxiosPromise<AgentGroupRes> {
            return localVarFp.createAgentGroup(saveAgentGroupReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an agent group by ID
         * @param {string} agentGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgentGroupById(agentGroupId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAgentGroupById(agentGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get agent group by ID
         * @param {string} agentGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentGroupById(agentGroupId: string, options?: RawAxiosRequestConfig): AxiosPromise<AgentGroupRes> {
            return localVarFp.getAgentGroupById(agentGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get jobs linked to a specific agent group
         * @param {string} agentGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentGroupLinkedJobs(agentGroupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SimpleJobNameRes>> {
            return localVarFp.getAgentGroupLinkedJobs(agentGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get jobs linked to a specific agent
         * @param {AgentReq} agentReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentLinkedJobs(agentReq: AgentReq, options?: RawAxiosRequestConfig): AxiosPromise<Array<SimpleJobNameRes>> {
            return localVarFp.getAgentLinkedJobs(agentReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all agent groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAgentGroup(options?: RawAxiosRequestConfig): AxiosPromise<Array<AgentGroupRes>> {
            return localVarFp.getAllAgentGroup(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle active state of an agent group
         * @param {string} agentGroupId 
         * @param {SwitchActiveReq} switchActiveReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        switchActiveAgentGroup(agentGroupId: string, switchActiveReq: SwitchActiveReq, options?: RawAxiosRequestConfig): AxiosPromise<AgentGroupRes> {
            return localVarFp.switchActiveAgentGroup(agentGroupId, switchActiveReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing agent group
         * @param {string} agentGroupId 
         * @param {SaveAgentGroupReq} saveAgentGroupReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgentGroup(agentGroupId: string, saveAgentGroupReq: SaveAgentGroupReq, options?: RawAxiosRequestConfig): AxiosPromise<AgentGroupRes> {
            return localVarFp.updateAgentGroup(agentGroupId, saveAgentGroupReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgentGroupApi - object-oriented interface
 * @export
 * @class AgentGroupApi
 * @extends {BaseAPI}
 */
export class AgentGroupApi extends BaseAPI {
    /**
     * 
     * @summary Test connection for given agents
     * @param {Array<AgentReq>} agentReqList 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGroupApi
     */
    public agentConnectionTest(agentReqList: Array<AgentReq>, options?: RawAxiosRequestConfig) {
        return AgentGroupApiFp(this.configuration).agentConnectionTest(agentReqList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test connection for all agents in a group
     * @param {string} agentGroupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGroupApi
     */
    public agentGroupConnectionTest(agentGroupId: string, options?: RawAxiosRequestConfig) {
        return AgentGroupApiFp(this.configuration).agentGroupConnectionTest(agentGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new agent group
     * @param {SaveAgentGroupReq} saveAgentGroupReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGroupApi
     */
    public createAgentGroup(saveAgentGroupReq: SaveAgentGroupReq, options?: RawAxiosRequestConfig) {
        return AgentGroupApiFp(this.configuration).createAgentGroup(saveAgentGroupReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an agent group by ID
     * @param {string} agentGroupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGroupApi
     */
    public deleteAgentGroupById(agentGroupId: string, options?: RawAxiosRequestConfig) {
        return AgentGroupApiFp(this.configuration).deleteAgentGroupById(agentGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get agent group by ID
     * @param {string} agentGroupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGroupApi
     */
    public getAgentGroupById(agentGroupId: string, options?: RawAxiosRequestConfig) {
        return AgentGroupApiFp(this.configuration).getAgentGroupById(agentGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get jobs linked to a specific agent group
     * @param {string} agentGroupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGroupApi
     */
    public getAgentGroupLinkedJobs(agentGroupId: string, options?: RawAxiosRequestConfig) {
        return AgentGroupApiFp(this.configuration).getAgentGroupLinkedJobs(agentGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get jobs linked to a specific agent
     * @param {AgentReq} agentReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGroupApi
     */
    public getAgentLinkedJobs(agentReq: AgentReq, options?: RawAxiosRequestConfig) {
        return AgentGroupApiFp(this.configuration).getAgentLinkedJobs(agentReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all agent groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGroupApi
     */
    public getAllAgentGroup(options?: RawAxiosRequestConfig) {
        return AgentGroupApiFp(this.configuration).getAllAgentGroup(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle active state of an agent group
     * @param {string} agentGroupId 
     * @param {SwitchActiveReq} switchActiveReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGroupApi
     */
    public switchActiveAgentGroup(agentGroupId: string, switchActiveReq: SwitchActiveReq, options?: RawAxiosRequestConfig) {
        return AgentGroupApiFp(this.configuration).switchActiveAgentGroup(agentGroupId, switchActiveReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing agent group
     * @param {string} agentGroupId 
     * @param {SaveAgentGroupReq} saveAgentGroupReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGroupApi
     */
    public updateAgentGroup(agentGroupId: string, saveAgentGroupReq: SaveAgentGroupReq, options?: RawAxiosRequestConfig) {
        return AgentGroupApiFp(this.configuration).updateAgentGroup(agentGroupId, saveAgentGroupReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobApi - axios parameter creator
 * @export
 */
export const JobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new job to the system
         * @summary Create a new job
         * @param {SaveJobReq} saveJobReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob: async (saveJobReq: SaveJobReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveJobReq' is not null or undefined
            assertParamExists('createJob', 'saveJobReq', saveJobReq)
            const localVarPath = `/api/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveJobReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a job from the system
         * @summary Delete a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobById: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobById', 'jobId', jobId)
            const localVarPath = `/api/jobs/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve specific job details
         * @summary Get job by ID
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobById: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobById', 'jobId', jobId)
            const localVarPath = `/api/jobs/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for jobs based on criteria
         * @summary Retrieve all jobs
         * @param {JobSearchReq} req 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchJob: async (req: JobSearchReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('searchJob', 'req', req)
            const localVarPath = `/api/job/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (req !== undefined) {
                for (const [key, value] of Object.entries(req)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable or disable the active status of a job
         * @summary Switch job active status
         * @param {string} jobId 
         * @param {SwitchActiveReq} switchActiveReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        switchActiveJob: async (jobId: string, switchActiveReq: SwitchActiveReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('switchActiveJob', 'jobId', jobId)
            // verify required parameter 'switchActiveReq' is not null or undefined
            assertParamExists('switchActiveJob', 'switchActiveReq', switchActiveReq)
            const localVarPath = `/api/jobs/{jobId}/switchActive`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(switchActiveReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify an existing job
         * @summary Update a job
         * @param {string} jobId 
         * @param {SaveJobReq} saveJobReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJob: async (jobId: string, saveJobReq: SaveJobReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('updateJob', 'jobId', jobId)
            // verify required parameter 'saveJobReq' is not null or undefined
            assertParamExists('updateJob', 'saveJobReq', saveJobReq)
            const localVarPath = `/api/jobs/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveJobReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobApi - functional programming interface
 * @export
 */
export const JobApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new job to the system
         * @summary Create a new job
         * @param {SaveJobReq} saveJobReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJob(saveJobReq: SaveJobReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJob(saveJobReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.createJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a job from the system
         * @summary Delete a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobById(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobById(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.deleteJobById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve specific job details
         * @summary Get job by ID
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobById(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobById(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.getJobById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for jobs based on criteria
         * @summary Retrieve all jobs
         * @param {JobSearchReq} req 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchJob(req: JobSearchReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedResultJobRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchJob(req, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.searchJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable or disable the active status of a job
         * @summary Switch job active status
         * @param {string} jobId 
         * @param {SwitchActiveReq} switchActiveReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async switchActiveJob(jobId: string, switchActiveReq: SwitchActiveReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.switchActiveJob(jobId, switchActiveReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.switchActiveJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify an existing job
         * @summary Update a job
         * @param {string} jobId 
         * @param {SaveJobReq} saveJobReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateJob(jobId: string, saveJobReq: SaveJobReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateJob(jobId, saveJobReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.updateJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobApi - factory interface
 * @export
 */
export const JobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobApiFp(configuration)
    return {
        /**
         * Add a new job to the system
         * @summary Create a new job
         * @param {SaveJobReq} saveJobReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob(saveJobReq: SaveJobReq, options?: RawAxiosRequestConfig): AxiosPromise<JobRes> {
            return localVarFp.createJob(saveJobReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a job from the system
         * @summary Delete a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobById(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteJobById(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve specific job details
         * @summary Get job by ID
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobById(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<JobRes> {
            return localVarFp.getJobById(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for jobs based on criteria
         * @summary Retrieve all jobs
         * @param {JobSearchReq} req 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchJob(req: JobSearchReq, options?: RawAxiosRequestConfig): AxiosPromise<PagedResultJobRes> {
            return localVarFp.searchJob(req, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable or disable the active status of a job
         * @summary Switch job active status
         * @param {string} jobId 
         * @param {SwitchActiveReq} switchActiveReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        switchActiveJob(jobId: string, switchActiveReq: SwitchActiveReq, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.switchActiveJob(jobId, switchActiveReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify an existing job
         * @summary Update a job
         * @param {string} jobId 
         * @param {SaveJobReq} saveJobReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJob(jobId: string, saveJobReq: SaveJobReq, options?: RawAxiosRequestConfig): AxiosPromise<JobRes> {
            return localVarFp.updateJob(jobId, saveJobReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobApi - object-oriented interface
 * @export
 * @class JobApi
 * @extends {BaseAPI}
 */
export class JobApi extends BaseAPI {
    /**
     * Add a new job to the system
     * @summary Create a new job
     * @param {SaveJobReq} saveJobReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public createJob(saveJobReq: SaveJobReq, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).createJob(saveJobReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a job from the system
     * @summary Delete a job
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public deleteJobById(jobId: string, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).deleteJobById(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve specific job details
     * @summary Get job by ID
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getJobById(jobId: string, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).getJobById(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for jobs based on criteria
     * @summary Retrieve all jobs
     * @param {JobSearchReq} req 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public searchJob(req: JobSearchReq, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).searchJob(req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable or disable the active status of a job
     * @summary Switch job active status
     * @param {string} jobId 
     * @param {SwitchActiveReq} switchActiveReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public switchActiveJob(jobId: string, switchActiveReq: SwitchActiveReq, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).switchActiveJob(jobId, switchActiveReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify an existing job
     * @summary Update a job
     * @param {string} jobId 
     * @param {SaveJobReq} saveJobReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public updateJob(jobId: string, saveJobReq: SaveJobReq, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).updateJob(jobId, saveJobReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobExecutionApi - axios parameter creator
 * @export
 */
export const JobExecutionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Executes the specified job by ID
         * @summary Execute a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeJob: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('executeJob', 'jobId', jobId)
            const localVarPath = `/api/jobs/{jobId}/execute`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a specific job execution
         * @summary Get job execution by ID
         * @param {string} jobId 
         * @param {number} jobExecutionNo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobExecutionById: async (jobId: string, jobExecutionNo: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobExecutionById', 'jobId', jobId)
            // verify required parameter 'jobExecutionNo' is not null or undefined
            assertParamExists('getJobExecutionById', 'jobExecutionNo', jobExecutionNo)
            const localVarPath = `/api/jobs/{jobId}/executions/{jobExecutionNo}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"jobExecutionNo"}}`, encodeURIComponent(String(jobExecutionNo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch live logs for the specified job execution
         * @summary Get live logs for job execution
         * @param {string} jobId 
         * @param {number} jobExecutionNo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveLog: async (jobId: string, jobExecutionNo: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getLiveLog', 'jobId', jobId)
            // verify required parameter 'jobExecutionNo' is not null or undefined
            assertParamExists('getLiveLog', 'jobExecutionNo', jobExecutionNo)
            const localVarPath = `/api/jobs/{jobId}/executions/{jobExecutionNo}/logs`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"jobExecutionNo"}}`, encodeURIComponent(String(jobExecutionNo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search job executions based on given criteria
         * @summary Search job executions
         * @param {JobExecutionSearchReq} jobExecutionSearchReq Search filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchJobExecution: async (jobExecutionSearchReq: JobExecutionSearchReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobExecutionSearchReq' is not null or undefined
            assertParamExists('searchJobExecution', 'jobExecutionSearchReq', jobExecutionSearchReq)
            const localVarPath = `/api/jobExecution/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobExecutionSearchReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stops the specified job execution
         * @summary Stop job execution
         * @param {string} jobId 
         * @param {number} jobExecutionNo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopJobExecution: async (jobId: string, jobExecutionNo: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('stopJobExecution', 'jobId', jobId)
            // verify required parameter 'jobExecutionNo' is not null or undefined
            assertParamExists('stopJobExecution', 'jobExecutionNo', jobExecutionNo)
            const localVarPath = `/api/jobs/{jobId}/executions/{jobExecutionNo}/stop`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"jobExecutionNo"}}`, encodeURIComponent(String(jobExecutionNo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobExecutionApi - functional programming interface
 * @export
 */
export const JobExecutionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobExecutionApiAxiosParamCreator(configuration)
    return {
        /**
         * Executes the specified job by ID
         * @summary Execute a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeJob(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobExecuteRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeJob(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobExecutionApi.executeJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of a specific job execution
         * @summary Get job execution by ID
         * @param {string} jobId 
         * @param {number} jobExecutionNo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobExecutionById(jobId: string, jobExecutionNo: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobExecutionRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobExecutionById(jobId, jobExecutionNo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobExecutionApi.getJobExecutionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch live logs for the specified job execution
         * @summary Get live logs for job execution
         * @param {string} jobId 
         * @param {number} jobExecutionNo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveLog(jobId: string, jobExecutionNo: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SshLiveLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveLog(jobId, jobExecutionNo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobExecutionApi.getLiveLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search job executions based on given criteria
         * @summary Search job executions
         * @param {JobExecutionSearchReq} jobExecutionSearchReq Search filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchJobExecution(jobExecutionSearchReq: JobExecutionSearchReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedResultJobExecutionRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchJobExecution(jobExecutionSearchReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobExecutionApi.searchJobExecution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stops the specified job execution
         * @summary Stop job execution
         * @param {string} jobId 
         * @param {number} jobExecutionNo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopJobExecution(jobId: string, jobExecutionNo: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopJobExecution(jobId, jobExecutionNo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobExecutionApi.stopJobExecution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobExecutionApi - factory interface
 * @export
 */
export const JobExecutionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobExecutionApiFp(configuration)
    return {
        /**
         * Executes the specified job by ID
         * @summary Execute a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeJob(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<JobExecuteRes> {
            return localVarFp.executeJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a specific job execution
         * @summary Get job execution by ID
         * @param {string} jobId 
         * @param {number} jobExecutionNo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobExecutionById(jobId: string, jobExecutionNo: number, options?: RawAxiosRequestConfig): AxiosPromise<JobExecutionRes> {
            return localVarFp.getJobExecutionById(jobId, jobExecutionNo, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch live logs for the specified job execution
         * @summary Get live logs for job execution
         * @param {string} jobId 
         * @param {number} jobExecutionNo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveLog(jobId: string, jobExecutionNo: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<SshLiveLog>> {
            return localVarFp.getLiveLog(jobId, jobExecutionNo, options).then((request) => request(axios, basePath));
        },
        /**
         * Search job executions based on given criteria
         * @summary Search job executions
         * @param {JobExecutionSearchReq} jobExecutionSearchReq Search filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchJobExecution(jobExecutionSearchReq: JobExecutionSearchReq, options?: RawAxiosRequestConfig): AxiosPromise<PagedResultJobExecutionRes> {
            return localVarFp.searchJobExecution(jobExecutionSearchReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Stops the specified job execution
         * @summary Stop job execution
         * @param {string} jobId 
         * @param {number} jobExecutionNo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopJobExecution(jobId: string, jobExecutionNo: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stopJobExecution(jobId, jobExecutionNo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobExecutionApi - object-oriented interface
 * @export
 * @class JobExecutionApi
 * @extends {BaseAPI}
 */
export class JobExecutionApi extends BaseAPI {
    /**
     * Executes the specified job by ID
     * @summary Execute a job
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobExecutionApi
     */
    public executeJob(jobId: string, options?: RawAxiosRequestConfig) {
        return JobExecutionApiFp(this.configuration).executeJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of a specific job execution
     * @summary Get job execution by ID
     * @param {string} jobId 
     * @param {number} jobExecutionNo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobExecutionApi
     */
    public getJobExecutionById(jobId: string, jobExecutionNo: number, options?: RawAxiosRequestConfig) {
        return JobExecutionApiFp(this.configuration).getJobExecutionById(jobId, jobExecutionNo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch live logs for the specified job execution
     * @summary Get live logs for job execution
     * @param {string} jobId 
     * @param {number} jobExecutionNo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobExecutionApi
     */
    public getLiveLog(jobId: string, jobExecutionNo: number, options?: RawAxiosRequestConfig) {
        return JobExecutionApiFp(this.configuration).getLiveLog(jobId, jobExecutionNo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search job executions based on given criteria
     * @summary Search job executions
     * @param {JobExecutionSearchReq} jobExecutionSearchReq Search filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobExecutionApi
     */
    public searchJobExecution(jobExecutionSearchReq: JobExecutionSearchReq, options?: RawAxiosRequestConfig) {
        return JobExecutionApiFp(this.configuration).searchJobExecution(jobExecutionSearchReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stops the specified job execution
     * @summary Stop job execution
     * @param {string} jobId 
     * @param {number} jobExecutionNo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobExecutionApi
     */
    public stopJobExecution(jobId: string, jobExecutionNo: number, options?: RawAxiosRequestConfig) {
        return JobExecutionApiFp(this.configuration).stopJobExecution(jobId, jobExecutionNo, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobHistoryApi - axios parameter creator
 * @export
 */
export const JobHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the details of a specific job history entry
         * @summary Get job history details
         * @param {string} jobId 
         * @param {number} jobHistoryNo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobHistoryById: async (jobId: string, jobHistoryNo: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobHistoryById', 'jobId', jobId)
            // verify required parameter 'jobHistoryNo' is not null or undefined
            assertParamExists('getJobHistoryById', 'jobHistoryNo', jobHistoryNo)
            const localVarPath = `/api/jobs/{jobId}/history/{jobHistoryNo}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"jobHistoryNo"}}`, encodeURIComponent(String(jobHistoryNo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search job histories
         * @summary search job histories
         * @param {string} jobId 
         * @param {JobHistorySearchReq} jobHistorySearchReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchJobHistory: async (jobId: string, jobHistorySearchReq: JobHistorySearchReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('searchJobHistory', 'jobId', jobId)
            // verify required parameter 'jobHistorySearchReq' is not null or undefined
            assertParamExists('searchJobHistory', 'jobHistorySearchReq', jobHistorySearchReq)
            const localVarPath = `/api/jobs/{jobId}/history`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobHistorySearchReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobHistoryApi - functional programming interface
 * @export
 */
export const JobHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the details of a specific job history entry
         * @summary Get job history details
         * @param {string} jobId 
         * @param {number} jobHistoryNo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobHistoryById(jobId: string, jobHistoryNo: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobHistoryRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobHistoryById(jobId, jobHistoryNo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobHistoryApi.getJobHistoryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search job histories
         * @summary search job histories
         * @param {string} jobId 
         * @param {JobHistorySearchReq} jobHistorySearchReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchJobHistory(jobId: string, jobHistorySearchReq: JobHistorySearchReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedResultJobHistoryRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchJobHistory(jobId, jobHistorySearchReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobHistoryApi.searchJobHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobHistoryApi - factory interface
 * @export
 */
export const JobHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobHistoryApiFp(configuration)
    return {
        /**
         * Retrieve the details of a specific job history entry
         * @summary Get job history details
         * @param {string} jobId 
         * @param {number} jobHistoryNo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobHistoryById(jobId: string, jobHistoryNo: number, options?: RawAxiosRequestConfig): AxiosPromise<JobHistoryRes> {
            return localVarFp.getJobHistoryById(jobId, jobHistoryNo, options).then((request) => request(axios, basePath));
        },
        /**
         * Search job histories
         * @summary search job histories
         * @param {string} jobId 
         * @param {JobHistorySearchReq} jobHistorySearchReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchJobHistory(jobId: string, jobHistorySearchReq: JobHistorySearchReq, options?: RawAxiosRequestConfig): AxiosPromise<PagedResultJobHistoryRes> {
            return localVarFp.searchJobHistory(jobId, jobHistorySearchReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobHistoryApi - object-oriented interface
 * @export
 * @class JobHistoryApi
 * @extends {BaseAPI}
 */
export class JobHistoryApi extends BaseAPI {
    /**
     * Retrieve the details of a specific job history entry
     * @summary Get job history details
     * @param {string} jobId 
     * @param {number} jobHistoryNo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobHistoryApi
     */
    public getJobHistoryById(jobId: string, jobHistoryNo: number, options?: RawAxiosRequestConfig) {
        return JobHistoryApiFp(this.configuration).getJobHistoryById(jobId, jobHistoryNo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search job histories
     * @summary search job histories
     * @param {string} jobId 
     * @param {JobHistorySearchReq} jobHistorySearchReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobHistoryApi
     */
    public searchJobHistory(jobId: string, jobHistorySearchReq: JobHistorySearchReq, options?: RawAxiosRequestConfig) {
        return JobHistoryApiFp(this.configuration).searchJobHistory(jobId, jobHistorySearchReq, options).then((request) => request(this.axios, this.basePath));
    }
}



